import numpy as np
import random
import matplotlib.pyplot as plt
from collections import Counter

def simulate_realistic_squats(simulations=15000, transition_threshold=4, bad_squat_rate=0.05, dropout_rate=0.025):
    squat_score = 0
    prev_stage = ""
    scored_stage = ""
    frame_count = 0

    true_squats = 0
    false_positives = 0
    false_negatives = 0
    true_positives = 0
    true_negatives = 0

    logs = []

    for i in range(simulations):
        is_bad_squat = random.random() < bad_squat_rate
        has_dropout = random.random() < dropout_rate

        if not is_bad_squat:
            true_squats += 1

        squat_detected = False

        # === Standing Phase ===
        stand_frames = random.randint(4, 10)
        for _ in range(stand_frames):
            if random.random() < dropout_rate:
                continue

            left_knee_angle = 170 + random.uniform(-5, 5)
            right_knee_angle = 170 + random.uniform(-5, 5)
            detected_stage = ""

            if left_knee_angle <= 90 and right_knee_angle <= 90:
                detected_stage = "Squat"

            if detected_stage == prev_stage:
                frame_count += 1
            else:
                frame_count = 0

            if frame_count >= transition_threshold:
                if detected_stage != scored_stage:
                    if detected_stage == "Squat":
                        squat_score += 1
                        squat_detected = True
                        if is_bad_squat:
                            false_positives += 1
                        else:
                            true_positives += 1
                    scored_stage = detected_stage
                frame_count = 0

            prev_stage = detected_stage

        # === Squat Phase ===
        squat_frames = random.randint(6, 12)
        for _ in range(squat_frames):
            if has_dropout or random.random() < dropout_rate:
                continue

            if is_bad_squat:
                left_knee_angle = 110 + random.uniform(-10, 10)
                right_knee_angle = 110 + random.uniform(-10, 10)
            else:
                left_knee_angle = 45 + random.uniform(-5, 5)
                right_knee_angle = 45 + random.uniform(-5, 5)

            detected_stage = ""

            if left_knee_angle <= 90 and right_knee_angle <= 90:
                detected_stage = "Squat"

            if detected_stage == prev_stage:
                frame_count += 1
            else:
                frame_count = 0

            if frame_count >= transition_threshold:
                if detected_stage != scored_stage:
                    if detected_stage == "Squat":
                        squat_score += 1
                        squat_detected = True
                        if is_bad_squat:
                            false_positives += 1
                        else:
                            true_positives += 1
                    scored_stage = detected_stage
                frame_count = 0

            prev_stage = detected_stage

        # Determine outcome
        if not is_bad_squat and not squat_detected:
            false_negatives += 1
            outcome = "False Negative"
        elif is_bad_squat and not squat_detected:
            true_negatives += 1
            outcome = "True Negative"
        elif is_bad_squat and squat_detected:
            outcome = "False Positive"
        elif not is_bad_squat and squat_detected:
            outcome = "True Positive"
        else:
            outcome = "Undetected"

        logs.append(outcome)

    # === Final Metrics ===
    precision = (true_positives) / (true_positives + false_positives) if (true_positives + false_positives) else 0
    recall = (true_positives) / (true_positives + false_negatives) if (true_positives + false_negatives) else 0
    accuracy = (true_positives + true_negatives) / simulations

    # === Terminal Report ===
    print("\n=== Realistic Squat Simulation Report ===")
    print(f"Total Simulated Squats: {simulations}")
    print(f" - True Positives: {true_positives}")
    print(f" - False Positives: {false_positives}")
    print(f" - False Negatives: {false_negatives}")
    print(f" - True Negatives: {true_negatives}")
    print(f"Precision: {precision * 100:.2f}%")
    print(f"Recall:    {recall * 100:.2f}%")
    print(f"Accuracy:  {accuracy * 100:.2f}%")
    print("=========================================\n")

    # === Visualization ===
    outcome_counts = Counter(logs)

    # Pie Chart: Outcome distribution
    plt.figure(figsize=(6, 6))
    plt.pie(outcome_counts.values(), labels=outcome_counts.keys(), autopct='%1.1f%%', startangle=90)
    plt.title("Squat Detection Outcome Distribution")
    plt.axis('equal')
    plt.tight_layout()
    plt.show()

    # Bar Chart: Performance Metrics
    plt.figure(figsize=(6, 4))
    metrics = ['Precision', 'Recall', 'Accuracy']
    values = [precision * 100, recall * 100, accuracy * 100]
    bars = plt.bar(metrics, values)
    plt.ylim(0, 100)
    plt.ylabel("Percentage")
    plt.title("Model Performance Metrics")
    for bar in bars:
        yval = bar.get_height()
        plt.text(bar.get_x() + bar.get_width() / 2, yval + 1, f"{yval:.1f}%", ha='center')
    plt.tight_layout()
    plt.show()

# Run the simulation
if __name__ == "__main__":
    simulate_realistic_squats(
        simulations=15000,
        transition_threshold=4,
        bad_squat_rate=0.05,
        dropout_rate=0.025
    )

